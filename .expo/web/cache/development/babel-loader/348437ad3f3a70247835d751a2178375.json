{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _jsxFileName = \"/Users/denisbasyrov/Desktop/App/react_native_store_app_final/node_modules/expo-linear-gradient/build/LinearGradient.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport ColorPropType from \"react-native-web/dist/exports/ColorPropType\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport ViewPropTypes from \"react-native-web/dist/exports/ViewPropTypes\";\nimport processColor from \"react-native-web/dist/exports/processColor\";\nimport NativeLinearGradient from \"./NativeLinearGradient\";\n\nvar LinearGradient = function (_React$Component) {\n  _inherits(LinearGradient, _React$Component);\n\n  var _super = _createSuper(LinearGradient);\n\n  function LinearGradient() {\n    _classCallCheck(this, LinearGradient);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(LinearGradient, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          colors = _this$props.colors,\n          locations = _this$props.locations,\n          start = _this$props.start,\n          end = _this$props.end,\n          props = _objectWithoutProperties(_this$props, [\"colors\", \"locations\", \"start\", \"end\"]);\n\n      if (locations && colors.length !== locations.length) {\n        console.warn('LinearGradient colors and locations props should be arrays of the same length');\n        locations = locations.slice(0, colors.length);\n      }\n\n      return React.createElement(NativeLinearGradient, _extends({}, props, {\n        colors: Platform.select({\n          web: colors,\n          default: colors.map(processColor)\n        }),\n        locations: locations,\n        startPoint: _normalizePoint(start),\n        endPoint: _normalizePoint(end),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 12,\n          columnNumber: 17\n        }\n      }));\n    }\n  }]);\n\n  return LinearGradient;\n}(React.Component);\n\nexport { LinearGradient as default };\nLinearGradient.propTypes = _objectSpread(_objectSpread({}, ViewPropTypes), {}, {\n  colors: PropTypes.arrayOf(ColorPropType).isRequired,\n  locations: PropTypes.arrayOf(PropTypes.number),\n  start: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.number), PropTypes.object]),\n  end: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.number), PropTypes.object])\n});\n\nfunction _normalizePoint(point) {\n  if (!point) {\n    return undefined;\n  }\n\n  if (Array.isArray(point) && point.length !== 2) {\n    console.warn('start and end props for LinearGradient must be of the format [x,y] or {x, y}');\n    return undefined;\n  }\n\n  return Array.isArray(point) ? point : [point.x, point.y];\n}","map":{"version":3,"sources":["../src/LinearGradient.tsx"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA,OAAO,SAAP,MAAsB,YAAtB;AACA,OAAO,KAAP,MAAkB,OAAlB;;;;;AAGA,OAAO,oBAAP;;IAWqB,c;;;;;;;;;;;;;6BASb;AAAA,wBAC8C,KAAK,KADnD;AAAA,UACE,MADF,eACE,MADF;AAAA,UACU,SADV,eACU,SADV;AAAA,UACqB,KADrB,eACqB,KADrB;AAAA,UAC4B,GAD5B,eAC4B,GAD5B;AAAA,UACoC,KADpC;;AAGJ,UAAI,SAAS,IAAI,MAAM,CAAC,MAAP,KAAkB,SAAS,CAAC,MAA7C,EAAqD;AACnD,QAAA,OAAO,CAAC,IAAR,CAAa,+EAAb;AACA,QAAA,SAAS,GAAG,SAAS,CAAC,KAAV,CAAgB,CAAhB,EAAmB,MAAM,CAAC,MAA1B,CAAZ;AACD;;AAED,aACE,oBAAC,oBAAD,eACM,KADN;AAEE,QAAA,MAAM,EAAE,QAAQ,CAAC,MAAT,CAAgB;AACtB,UAAA,GAAG,EAAE,MADiB;AAEtB,UAAA,OAAO,EAAE,MAAM,CAAC,GAAP,CAAW,YAAX;AAFa,SAAhB,CAFV;AAME,QAAA,SAAS,EAAE,SANb;AAOE,QAAA,UAAU,EAAE,eAAe,CAAC,KAAD,CAP7B;AAQE,QAAA,QAAQ,EAAE,eAAe,CAAC,GAAD,CAR3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SADF;AAYD;;;;EA7ByC,KAAK,CAAC,S;;SAA7B,c;AACZ,cAAA,CAAA,SAAA,mCACF,aADE;AAEL,EAAA,MAAM,EAAE,SAAS,CAAC,OAAV,CAAkB,aAAlB,EAAiC,UAFpC;AAGL,EAAA,SAAS,EAAE,SAAS,CAAC,OAAV,CAAkB,SAAS,CAAC,MAA5B,CAHN;AAIL,EAAA,KAAK,EAAE,SAAS,CAAC,SAAV,CAAoB,CAAC,SAAS,CAAC,OAAV,CAAkB,SAAS,CAAC,MAA5B,CAAD,EAAsC,SAAS,CAAC,MAAhD,CAApB,CAJF;AAKL,EAAA,GAAG,EAAE,SAAS,CAAC,SAAV,CAAoB,CAAC,SAAS,CAAC,OAAV,CAAkB,SAAS,CAAC,MAA5B,CAAD,EAAsC,SAAS,CAAC,MAAhD,CAApB;AALA;;AA+BT,SAAS,eAAT,CAAyB,KAAzB,EAAwD;AACtD,MAAI,CAAC,KAAL,EAAY;AACV,WAAO,SAAP;AACD;;AAED,MAAI,KAAK,CAAC,OAAN,CAAc,KAAd,KAAwB,KAAK,CAAC,MAAN,KAAiB,CAA7C,EAAgD;AAC9C,IAAA,OAAO,CAAC,IAAR,CAAa,8EAAb;AACA,WAAO,SAAP;AACD;;AAED,SAAO,KAAK,CAAC,OAAN,CAAc,KAAd,IAAuB,KAAvB,GAA+B,CAAC,KAAK,CAAC,CAAP,EAAU,KAAK,CAAC,CAAhB,CAAtC;AACD","sourcesContent":["import PropTypes from 'prop-types';\nimport React from 'react';\nimport { ColorPropType, Platform, View, ViewPropTypes, processColor } from 'react-native';\n\nimport NativeLinearGradient from './NativeLinearGradient';\n\ntype Props = {\n  colors: string[];\n  locations?: number[] | null;\n  start?: Point | null;\n  end?: Point | null;\n} & React.ComponentProps<typeof View>;\n\ntype Point = { x: number; y: number } | [number, number];\n\nexport default class LinearGradient extends React.Component<Props> {\n  static propTypes = {\n    ...ViewPropTypes,\n    colors: PropTypes.arrayOf(ColorPropType).isRequired,\n    locations: PropTypes.arrayOf(PropTypes.number),\n    start: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.number), PropTypes.object]),\n    end: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.number), PropTypes.object]),\n  };\n\n  render() {\n    let { colors, locations, start, end, ...props } = this.props;\n\n    if (locations && colors.length !== locations.length) {\n      console.warn('LinearGradient colors and locations props should be arrays of the same length');\n      locations = locations.slice(0, colors.length);\n    }\n\n    return (\n      <NativeLinearGradient\n        {...props}\n        colors={Platform.select({\n          web: colors as any,\n          default: colors.map(processColor),\n        })}\n        locations={locations}\n        startPoint={_normalizePoint(start)}\n        endPoint={_normalizePoint(end)}\n      />\n    );\n  }\n}\n\nfunction _normalizePoint(point: Point | null | undefined): [number, number] | undefined {\n  if (!point) {\n    return undefined;\n  }\n\n  if (Array.isArray(point) && point.length !== 2) {\n    console.warn('start and end props for LinearGradient must be of the format [x,y] or {x, y}');\n    return undefined;\n  }\n\n  return Array.isArray(point) ? point : [point.x, point.y];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}